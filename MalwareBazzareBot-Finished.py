import discord
from discord.ext import commands, tasks
from dotenv import load_dotenv
import logging
import os
import json
import base64
import asyncio
import requests
from datetime import datetime

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Load environment variables from .env file
load_dotenv('private.env')

def get_env_variable(var_name, default=None, var_type=str):
    value = os.getenv(var_name, default)
    if value is None:
        raise ValueError(f"Environment variable '{var_name}' is not set.")
    return var_type(value)

# Environment variables
DISCORD_TOKEN = get_env_variable('DISCORD_TOKEN')
MALWAREBAZAAR_API_KEY = get_env_variable('MALWAREBAZAAR_API_KEY')
URLHAUS_API_KEY = get_env_variable('URLHAUS_API_KEY')
GITHUB_TOKEN = get_env_variable('GITHUB_TOKEN')
LOGGING_CHANNEL_ID = get_env_variable('LOGGING_CHANNEL_ID', var_type=int)
MALWARE_CHANNEL_ID = get_env_variable('MALWARE_CHANNEL_ID', var_type=int)
URLHAUS_CHANNEL_ID = get_env_variable('URLHAUS_CHANNEL_ID', var_type=int)
GITHUB_REPO_OWNER = get_env_variable('GITHUB_REPO_OWNER')
GITHUB_REPO_NAME = get_env_variable('GITHUB_REPO_NAME')
MALWAREBAZAAR_API_URL = get_env_variable('MALWAREBAZAAR_API_URL')
URLHAUS_API_URL = get_env_variable('URLHAUS_API_URL')

intents = discord.Intents.default()
bot = commands.AutoShardedBot(command_prefix='!', intents=intents, shard_count=2)  # Add intents argument

class MalwareBot:
    def __init__(self):
        self.seen_hashes = set()
        self.seen_urls = set()
        self.message_semaphore = asyncio.Semaphore(1)
        self.duplicate_samples = []  # To store duplicates
        self.periodic_check.start()  # Start the periodic task

    def upload_to_github(self, filename, file_content):
        headers = {
            'Authorization': f'token {GITHUB_TOKEN}',
            'Content-Type': 'application/json'
        }
        url = f'https://api.github.com/repos/{GITHUB_REPO_OWNER}/{GITHUB_REPO_NAME}/contents/{filename}'
        
        try:
            response = requests.get(url, headers=headers)
            response.raise_for_status()
            existing_file_sha = response.json().get('sha')
        except requests.exceptions.RequestException as e:
            existing_file_sha = None
            logger.error(f"Error fetching {filename} from GitHub: {e}")
        
        try:
            content_base64 = base64.b64encode(file_content.encode('utf-8')).decode('utf-8')
            payload = {
                'message': 'Automatic update',
                'content': content_base64
            }
            if existing_file_sha:
                payload['sha'] = existing_file_sha
            
            response = requests.put(url, headers=headers, json=payload)
            response.raise_for_status()
            logger.info(f"Uploaded {filename} to GitHub")
        except requests.exceptions.RequestException as e:
            logger.error(f"Error uploading {filename} to GitHub: {e}")

    def upload_files_to_github(self):
        with open('malware_samples.json', 'r') as f:
            malware_content = f.read()
        self.upload_to_github('malware_samples.json', malware_content)

        with open('urlhaus_samples.json', 'r') as f:
            urlhaus_content = f.read()
        self.upload_to_github('urlhaus_samples.json', urlhaus_content)

    def load_samples_from_json(self, filename):
        try:
            with open(filename, 'r') as f:
                return [json.loads(line.strip()) for line in f if line.strip()]
        except FileNotFoundError:
            return []

    def save_samples_to_json(self, samples, filename):
        with open(filename, 'w') as f:
            for sample in samples:
                json.dump(sample, f)
                f.write('\n')

    def obfuscate_url(self, url):
        return url.replace('http://', 'hxcx://').replace('https://', 'hxcxs://')

    async def log_to_channel(self, channel, message):
        if channel:
            try:
                message = self.obfuscate_url(message)  # Obfuscate URLs before sending
                async with self.message_semaphore:
                    await channel.send(message)
            except discord.HTTPException as e:
                if e.status == 429:
                    retry_after = float(e.response.headers.get('Retry-After', 1))
                    await asyncio.sleep(retry_after)
                    await self.log_to_channel(channel, message)
                else:
                    logger.error(f"Error sending message to channel: {e}")

    def is_duplicate_sample(self, sample, filename):
        stored_samples = self.load_samples_from_json(filename)
        for stored_sample in stored_samples:
            if 'url' in sample and 'url' in stored_sample and sample['url'] == stored_sample['url']:
                if sample not in self.duplicate_samples:
                    self.duplicate_samples.append(sample)
                return True
            if 'sha256_hash' in sample and 'sha256_hash' in stored_sample and sample['sha256_hash'] == stored_sample['sha256_hash']:
                if sample not in self.duplicate_samples:
                    self.duplicate_samples.append(sample)
                return True
        return False

    async def send_duplicates_to_channel(self, channel):
        if not self.duplicate_samples:
            return

        embed = discord.Embed(title="Duplicate Samples Found", description="The following samples are duplicates:", color=0xFF0000)
        for sample in self.duplicate_samples:
            if 'sha256_hash' in sample:
                embed.add_field(name="Duplicate SHA256 Hash", value=sample['sha256_hash'], inline=False)
            if 'url' in sample:
                embed.add_field(name="Duplicate URL", value=self.obfuscate_url(sample['url']), inline=False)

        await channel.send(embed=embed)
        self.duplicate_samples = []  # Clear the list after sending

    async def periodic_check(self):
        start_time = datetime.now()
        try:
            malware_samples = await self.fetch_recent_malware_samples()
            if malware_samples:
                channel = bot.get_channel(MALWARE_CHANNEL_ID)
                if channel:
                    await self.send_samples_embed(malware_samples, channel, "MalwareBazaar")

            urlhaus_samples = await self.fetch_recent_urlhaus_samples()
            if urlhaus_samples:
                channel = bot.get_channel(URLHAUS_CHANNEL_ID)
                if channel:
                    await self.send_samples_embed(urlhaus_samples, channel, "URLhaus")

            self.upload_files_to_github()
            await self.send_summary_log(malware_samples, urlhaus_samples, start_time)
            await self.send_duplicates_to_channel(bot.get_channel(LOGGING_CHANNEL_ID))  # Send duplicates

        except Exception as e:
            await self.log_to_channel(bot.get_channel(LOGGING_CHANNEL_ID), f"Error during periodic check: {e}")

    async def fetch_recent_malware_samples(self):
        try:
            headers = {'API-KEY': MALWAREBAZAAR_API_KEY}
            form_data = {"query": "get_recent", "selector": "time"}
            response = requests.post(MALWAREBAZAAR_API_URL, data=form_data, headers=headers)

            if response.status_code == 200:
                samples = response.json().get('data', [])[:25]
                filtered_samples = [
                    sample for sample in samples 
                    if sample.get('sha256_hash') and sample['sha256_hash'] not in self.seen_hashes and not self.is_duplicate_sample(sample, 'malware_samples.json')
                ]
                for sample in filtered_samples:
                    self.seen_hashes.add(sample['sha256_hash'])
                return filtered_samples
            else:
                await self.log_to_channel(bot.get_channel(LOGGING_CHANNEL_ID), f"Error fetching MalwareBazaar data: {response.status_code} - {response.text}")
                return None

        except Exception as e:
            await self.log_to_channel(bot.get_channel(LOGGING_CHANNEL_ID), f"Error fetching MalwareBazaar data: {e}")
            return None

    async def fetch_recent_urlhaus_samples(self):
        try:
            headers = {'User-Agent': 'Mozilla/5.0', 'API-Key': URLHAUS_API_KEY}
            response = requests.get(URLHAUS_API_URL, headers=headers)

            if response.status_code == 200:
                samples = response.json().get('urls', [])[:25]
                filtered_samples = [
                    sample for sample in samples 
                    if sample.get('url') and sample['url'] not in self.seen_urls and not self.is_duplicate_sample({'url': sample['url']}, 'urlhaus_samples.json')
                ]
                for sample in filtered_samples:
                    self.seen_urls.add(sample['url'])
                return filtered_samples
            else:
                await self.log_to_channel(bot.get_channel(LOGGING_CHANNEL_ID), f"Error fetching URLhaus data: {response.status_code} - {response.text}")
                return None

        except Exception as e:
            await self.log_to_channel(bot.get_channel(LOGGING_CHANNEL_ID), f"Error fetching URLhaus data: {e}")
            return None

    async def send_samples_embed(self, samples, channel, source):
        messages = []
        for sample in samples:
            try:
                if 'sha256_hash' in sample:
                    embed = self.create_malware_embed(sample)
                    messages.append(embed)
                    stored_samples = self.load_samples_from_json('malware_samples.json')
                    stored_samples.append({'sha256_hash': sample['sha256_hash']})
                    self.save_samples_to_json(stored_samples, 'malware_samples.json')
                elif 'url' in sample:
                    embed = self.create_url_embed(sample)
                    messages.append(embed)
                    stored_samples = self.load_samples_from_json('urlhaus_samples.json')
                    stored_samples.append({'url': sample['url']})
                    self.save_samples_to_json(stored_samples, 'urlhaus_samples.json')
            except Exception as e:
                await self.log_to_channel(bot.get_channel(LOGGING_CHANNEL_ID), f"Error creating embed: {e}")

        await self.send_messages_in_batches(channel, messages)

    async def send_messages_in_batches(self, channel, messages, batch_size=5):
        for i in range(0, len(messages), batch_size):
            batch = messages[i:i + batch_size]
            for message in batch:
                try:
                    async with self.message_semaphore:
                        if isinstance(message, discord.Embed):
                            if len(message.fields) > 25:
                                parts = self.split_embed_fields(message)
                                for part in parts:
                                    await channel.send(embed=part)
                            elif self.get_embed_size(message) > 6000:
                                parts = self.split_embed_size(message)
                                for part in parts:
                                    await channel.send(embed=part)
                            else:
                                await channel.send(embed=message)
                        else:
                            await channel.send(message)
                except discord.HTTPException as e:
                    if e.status == 429:
                        retry_after = float(e.response.headers.get('Retry-After', 1))
                        await asyncio.sleep(retry_after)
                        await self.send_messages_in_batches(channel, batch, batch_size)
                    else:
                        logger.error(f"Error sending message: {e}")
                        continue
            await asyncio.sleep(1)  # Avoid hitting rate limits too quickly

    def get_embed_size(self, embed):
        total_size = len(embed.title or '') + len(embed.description or '')
        for field in embed.fields:
            total_size += len(field.name) + len(field.value)
        return total_size

    def split_embed_fields(self, embed):
        parts = []
        current_part = discord.Embed(title=embed.title, color=embed.color, description=embed.description)
        current_fields = []

        for field in embed.fields:
            current_fields.append(field)
            if len(current_fields) == 25:
                for f in current_fields:
                    current_part.add_field(name=f.name, value=f.value, inline=f.inline)
                parts.append(current_part)
                current_part = discord.Embed(title=embed.title, color=embed.color, description=embed.description)
                current_fields = []

        if current_fields:
            for f in current_fields:
                current_part.add_field(name=f.name, value=f.value, inline=f.inline)
            parts.append(current_part)

        return parts

    def split_embed_size(self, embed):
        parts = []
        current_part = discord.Embed(title=embed.title, color=embed.color)
        current_size = 0

        if embed.description:
            desc = embed.description
            while len(desc) > 0:
                if len(desc) > 2048:
                    current_part.description = desc[:2048]
                    desc = desc[2048:]
                else:
                    current_part.description = desc
                    desc = ''
                current_size += len(current_part.description)
                if current_size > 6000:
                    parts.append(current_part)
                    current_part = discord.Embed(title=embed.title, color=embed.color)
                    current_size = 0
            parts.append(current_part)

        for field in embed.fields:
            if current_size + len(field.name) + len(field.value) + 2 > 6000:
                parts.append(current_part)
                current_part = discord.Embed(title=embed.title, color=embed.color)
                current_size = 0
            current_part.add_field(name=field.name, value=field.value, inline=field.inline)
            current_size += len(field.name) + len(field.value) + 2

        if current_size > 0:
            parts.append(current_part)
        
        return parts

    def create_malware_embed(self, sample):
        embed = discord.Embed(title="New Malware Sample Detected", color=discord.Color.greyple())
        embed.add_field(name="SHA256 Hash", value=sample['sha256_hash'], inline=False)
        embed.add_field(name="File Name", value=sample.get('file_name', 'N/A'), inline=False)
        tags = sample.get('tags', [])
        if not isinstance(tags, list):
            tags = [tags]
        tags = [str(tag) if tag is not None else 'N/A' for tag in tags]
        embed.add_field(name="Tags", value=', '.join(tags), inline=False)
        embed.add_field(name="Imphash", value=sample.get('imphash', 'N/A'), inline=False)
        embed.add_field(name="Tlsh", value=sample.get('tlsh', 'N/A'), inline=False)
        embed.add_field(name="SSDeep", value=sample.get('ssdeep', 'N/A'), inline=False)
        embed.add_field(name="Code Sign", value=', '.join([str(cs) if cs is not None else 'N/A' for cs in sample.get('code_sign', [])]), inline=False)
        embed.add_field(name="Intelligence ClamAV", value=sample.get('intelligence', {}).get('clamav', 'N/A'), inline=False)
        embed.add_field(name="Intelligence Downloads", value=sample.get('intelligence', {}).get('downloads', 'N/A'), inline=False)
        embed.add_field(name="Intelligence Uploads", value=sample.get('intelligence', {}).get('uploads', 'N/A'), inline=False)
        embed.add_field(name="Intelligence Mail", value=sample.get('intelligence', {}).get('mail', 'N/A'), inline=False)
        return embed

    def create_url_embed(self, sample):
        embed = discord.Embed(title="New Malicious URL Detected", color=discord.Color.red())
        embed.add_field(name="URL", value=self.obfuscate_url(sample['url']), inline=False)
        embed.add_field(name="ID", value=sample.get('id', 'N/A'), inline=False)
        embed.add_field(name="Threat", value=sample.get('threat', 'N/A'), inline=False)
        tags = sample.get('tags', [])
        if not isinstance(tags, list):
            tags = [tags]
        tags = [str(tag) if tag is not None else 'N/A' for tag in tags]
        embed.add_field(name="Tags", value=', '.join(tags), inline=False)
        embed.add_field(name="URL Status", value=sample.get('url_status', 'N/A'), inline=False)
        embed.add_field(name="Date Added", value=sample.get('date_added', 'N/A'), inline=False)
        embed.add_field(name="Reporter", value=sample.get('reporter', 'N/A'), inline=False)
        embed.add_field(name="Host", value=sample.get('host', 'N/A'), inline=False)
        embed.add_field(name="URL Haus Reference", value=sample.get('urlhaus_reference', 'N/A'), inline=False)
        embed.add_field(name="Time", value=sample.get('time', 'N/A'), inline=False)
        return embed

    async def send_summary_log(self, malware_samples, urlhaus_samples, start_time):
        channel = bot.get_channel(LOGGING_CHANNEL_ID)
        if channel:
            end_time = datetime.now()
            duration = end_time - start_time
            formatted_duration = str(duration).split('.')[0]  # Remove microseconds

            upload_times = {
                'malware_samples.json': end_time.strftime('%Y-%m-%d %H:%M:%S'),
                'urlhaus_samples.json': end_time.strftime('%Y-%m-%d %H:%M:%S')
            }

            embed = discord.Embed(title="Summary Log", color=discord.Color.blue())
            embed.add_field(name="MalwareBazaar Samples", value=len(malware_samples), inline=False)
            embed.add_field(name="URLhaus Samples", value=len(urlhaus_samples), inline=False)
            embed.add_field(name="JSON Files Uploaded", value=f"malware_samples.json at {upload_times['malware_samples.json']}\nurlhaus_samples.json at {upload_times['urlhaus_samples.json']}", inline=False)
            embed.add_field(name="Data Grab Finished At", value=end_time.strftime('%Y-%m-%d %H:%M:%S'), inline=False)
            embed.add_field(name="Time Taken", value=formatted_duration, inline=False)

            await channel.send(embed=embed)

    @tasks.loop(minutes=15)
    async def periodic_check(self):
        start_time = datetime.now()
        try:
            malware_samples = await self.fetch_recent_malware_samples()
            if malware_samples:
                channel = bot.get_channel(MALWARE_CHANNEL_ID)
                if channel:
                    await self.send_samples_embed(malware_samples, channel, "MalwareBazaar")

            urlhaus_samples = await self.fetch_recent_urlhaus_samples()
            if urlhaus_samples:
                channel = bot.get_channel(URLHAUS_CHANNEL_ID)
                if channel:
                    await self.send_samples_embed(urlhaus_samples, channel, "URLhaus")

            self.upload_files_to_github()
            await self.send_summary_log(malware_samples, urlhaus_samples, start_time)
            await self.send_duplicates_to_channel(bot.get_channel(LOGGING_CHANNEL_ID))  # Send duplicates

        except Exception as e:
            await self.log_to_channel(bot.get_channel(LOGGING_CHANNEL_ID), f"Error during periodic check: {e}")

@bot.event
async def on_ready():
    logger.info(f'Logged in as {bot.user.name}')
    bot_instance = MalwareBot()

@bot.event
async def on_message(message):
    if message.author == bot.user:
        return

    if message.content.startswith('!hello'):
        await message.channel.send('Hello!')

if __name__ == "__main__":
    bot.run(DISCORD_TOKEN)
